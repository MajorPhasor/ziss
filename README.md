# ziss
Ziss takes input from a USB GPS receiver and TLE data for the International Space Station (ISS) to predict passes and generates an APRS packet with your location to send to the amateur radio repeater. 

My goal for this project was to create a portable device that could be taken while hiking, and in the event of an emergency, would transmit an SOS message over the ISS APRS amateur radio repeater when it passes overhead.

I never got it to work with the ISS with a 5W handheld transciever, but was able to set the frequency for a local APRS digipeater and see my location plotted on aprs.fi. I may not have had enough power to overcome nearby stations transmitting to the ISS, so this would be a practical issue of the system.

The code was written for Python 2.7, with the goal of running it on a Raspberry Pi 3. I may have used a Behringer USB Audio device for the output instead of the built-in RPi output.


Dependencies
---
Raspbian Linux, or similar

Python 2.7, with:
• “serial” library to get data from GPS receiver
• “math” library for calculation of ISS location
• “time” library for calculation of ISS location
• “datetime” library for calculation of ISS location
• “ephem” library for calculation of ISS location
• “pydub” library for adding two .wav files together (may need to be installed using pip)

Direwolf (Software TNC Application)
• gen_packets component for audio file generation containing APRS packet data

GPS Data
---
I used a SiRFstarIII USB GPS receiver for this project. The SiRFstarIII supports two operating modes: one which outputs a standardized serial data stream of NMEA-formatted data, and the other which is proprietary and allows more advanced information to be read from the GPS receiver, and control messages to be sent to the receiver. Initially, I tried a suite of applications available online to automatically generate a constant APRS position beacon, but it seemed too complicated. The Linux program gpsd, a dependency of the application suite, appears to have switched the receiver to the proprietary SiRF protocol mode. This rendered the serial data stream was unintelligible, so I had to use a special application to switch the receiver to serial data mode. In the end, the Python script parses out one line of the NMEA data set and creates position data variables usable for the rest of the application, and suitable for testing by input into Google Maps.

Vox Circuit
---
I made a vox circuit to trigger transmit on my Yaesu VX-6 when there was an audio output. I based it on a schematic from the Radio Society of Norwich. The original page is down, but there's an archive here:
https://web.archive.org/web/20170609084857/http://www.rason.org/Projects/basicvox/basicvox.htm
The circuit behaves as a level detector. First, the input is AC-coupled using C1. The signal is then amplified using the first op-amp circuit, an inverting amplifier. The second op-amp circuit compares these values to a voltage set by R6. D1 rectifies the audio signal and is used to charge C2. C2 can drain to ground through R8 and R9. When enough of an input signal is given, charge on capacitor C2 is able to build up quickly enough to turn on transistor Q1, emulating a TNC PTT signal, and pulling the mean voltage of the audio signal low enough to activate the transmit on the Yaseu VX-6R.
In place of the 1458 dual op-amp IC, I used a TL072 dual op-amp IC. I used a 22uF capacitor was used in place of C2 to get a quicker response of the output, and different but similar resistor values for R5/R7 based on the components I had on hand. I used a 9V alkaline battery to supply Vcc.

Data Modulation and the APRS Zero File
---
Various programs are available to produce audio for APRS data packets, but each had its own issues for this application. I used a component of the Direwolf virtual TNC application called gen_packets. This component accepts a text file as input in a command line function and generates an audio file with an APRS data packet.
Internet-connected repeaters typically have some delay time for which the receiver squelch must be broken, so the audio file must contain enough “zeros” encoded at the beginning to break the receiver squelch before the receiver’s TNC starts to decode the APRS data packet. The audio files generated by gen_packets did not have enough zeros prefixing the packet, so I created an an audio file of all zeros using another application. The ziss.py script and merges the two audio files together using the pydub component’s AudioSegment function.

Improvements
--------------
It would be great to have this run on some embedded device (like the TinyTrak) so it uses less power and is more portable.
The code could also be tidied up and include better comments.

This was my first Python project, and my first on GitHub. I hope you'll find some of this code or information useful!
